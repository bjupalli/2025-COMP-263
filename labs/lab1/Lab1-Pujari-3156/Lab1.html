<!DOCTYPE html>
<html>
<head>
  <title>COMP-263 Lab 1 ‚Äì AgricultureDB</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    
    h2 {
      color: #2c3e50;
      text-align: center;
      margin-bottom: 30px;
    }
    
    .button-container {
      text-align: center;
      margin-bottom: 30px;
    }
    
    button {
      background: #3498db;
      color: white;
      border: none;
      padding: 12px 24px;
      margin: 0 10px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background: #2980b9;
    }
    
    button:disabled {
      background: #95a5a6;
      cursor: not-allowed;
    }
    
    .status {
      text-align: center;
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
      font-weight: bold;
    }
    
    .success {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
    }
    
    .error {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
    }
    
    .info {
      background: #d1ecf1;
      border: 1px solid #bee5eb;
      color: #0c5460;
    }
    
    .progress-bar {
      width: 100%;
      height: 20px;
      background-color: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #45a049);
      transition: width 0.3s ease;
      width: 0%;
    }
    
    .console-output {
      background: #2c3e50;
      color: #ecf0f1;
      padding: 20px;
      border-radius: 5px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h2>üå± AgricultureDB IndexedDB Demo</h2>
  
  <div class="button-container">
    <button id="storeBtn" onclick="storeData()">Store 10,000 Entries</button>
    <button id="logBtn" onclick="logFarmData()">Log Data to Console</button>
    <button id="clearBtn" onclick="clearDatabase()">Clear Database</button>
    <button id="countBtn" onclick="countEntries()">Count Entries</button>
  </div>

  <div id="status"></div>
  
  <div id="progress-container" style="display: none;">
    <div>Progress: <span id="progress-text">0%</span></div>
    <div class="progress-bar">
      <div class="progress-fill" id="progress-fill"></div>
    </div>
  </div>

  <div class="console-output" id="console-output">
    Console output will appear here...
  </div>

  <script>
    const dbName = "AgricultureDB";
    const storeName = "FarmData";
    const DB_VERSION = 1;

    let consoleOutput = document.getElementById('console-output');
    
    // Custom console log function to display in UI
    function logToConsole(message) {
      console.log(message);
      consoleOutput.textContent += message + '\n';
      consoleOutput.scrollTop = consoleOutput.scrollHeight;
    }

    function showStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      statusDiv.innerHTML = `<div class="${type}">${message}</div>`;
      setTimeout(() => {
        statusDiv.innerHTML = '';
      }, 5000);
    }

    function updateProgress(current, total) {
      const percentage = Math.round((current / total) * 100);
      document.getElementById('progress-text').textContent = `${percentage}% (${current}/${total})`;
      document.getElementById('progress-fill').style.width = `${percentage}%`;
    }

    function showProgress() {
      document.getElementById('progress-container').style.display = 'block';
    }

    function hideProgress() {
      document.getElementById('progress-container').style.display = 'none';
    }

    // FIXED: Proper IndexedDB opening with error handling
    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, DB_VERSION);
        
        request.onerror = () => {
          console.error("IndexedDB error:", request.error);
          reject(request.error);
        };
        
        request.onblocked = () => {
          console.warn("IndexedDB blocked - close other tabs with this database");
          reject(new Error("Database blocked"));
        };
        
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          
          // FIXED: Check if store already exists before creating
          if (!db.objectStoreNames.contains(storeName)) {
            const store = db.createObjectStore(storeName, { 
              keyPath: 'id',
              autoIncrement: true 
            });
            
            // FIXED: Add indexes for better querying
            store.createIndex('timestamp', 'timestamp', { unique: false });
            store.createIndex('gpsCoordinates', 'gpsCoordinates', { unique: false });
            
            console.log("Object store created successfully");
          }
        };
        
        request.onsuccess = () => {
          const db = request.result;
          
          // FIXED: Add version change handler
          db.onversionchange = () => {
            db.close();
            alert("Database updated by another tab. Please refresh the page.");
          };
          
          resolve(db);
        };
      });
    }

    // FIXED: Better random data generation
    function generateEntry() {
      const crops = ['wheat', 'corn', 'rice', 'soybeans', 'barley', 'oats', 'cotton', 'tomatoes', 'potatoes', 'carrots'];
      const randomCrop = crops[Math.floor(Math.random() * crops.length)];
      
      return {
        sensorReadings: Array.from({ length: 5 }, () => 
          parseFloat((Math.random() * 100).toFixed(2))
        ),
        cropPhoto: `images/${randomCrop}_${Math.floor(Math.random() * 10) + 1}.jpg`,
        farmerNote: `${randomCrop} field observation - ${Math.random().toString(36).substring(2, 15)}`,
        gpsCoordinates: {
          latitude: parseFloat((Math.random() * 180 - 90).toFixed(6)),
          longitude: parseFloat((Math.random() * 360 - 180).toFixed(6))
        },
        cropType: randomCrop,
        soilMoisture: parseFloat((Math.random() * 100).toFixed(1)),
        temperature: parseFloat((Math.random() * 40 + 5).toFixed(1)), // 5-45¬∞C
        humidity: parseFloat((Math.random() * 100).toFixed(1)),
        timestamp: new Date().toISOString()
      };
    }

    // FIXED: Batch processing with progress tracking and error handling
    async function storeData() {
      const storeBtn = document.getElementById('storeBtn');
      storeBtn.disabled = true;
      
      try {
        showProgress();
        showStatus("Starting to store 10,000 entries...", 'info');
        
        const db = await openDB();
        const BATCH_SIZE = 500; // Process in batches
        const TOTAL_ENTRIES = 10000;
        
        for (let batch = 0; batch < TOTAL_ENTRIES; batch += BATCH_SIZE) {
          const tx = db.transaction(storeName, "readwrite");
          const store = tx.objectStore(storeName);
          
          // FIXED: Proper transaction error handling
          tx.onerror = (event) => {
            console.error("Transaction error:", event);
            throw new Error("Transaction failed");
          };
          
          const batchEnd = Math.min(batch + BATCH_SIZE, TOTAL_ENTRIES);
          
          for (let i = batch; i < batchEnd; i++) {
            const entry = generateEntry();
            const request = store.add(entry);
            
            // FIXED: Individual request error handling
            request.onerror = () => {
              console.error(`Failed to add entry ${i + 1}`);
            };
          }
          
          // FIXED: Wait for transaction to complete before next batch
          await new Promise((resolve, reject) => {
            tx.oncomplete = resolve;
            tx.onerror = reject;
          });
          
          updateProgress(batchEnd, TOTAL_ENTRIES);
        }
        
        db.close();
        showStatus("‚úÖ Successfully stored 10,000 entries in IndexedDB!", 'success');
        logToConsole(`‚úÖ Successfully stored ${TOTAL_ENTRIES} entries in IndexedDB at ${new Date().toLocaleString()}`);
        
      } catch (error) {
        console.error("Error storing data:", error);
        showStatus(`‚ùå Error storing data: ${error.message}`, 'error');
        logToConsole(`‚ùå Error storing data: ${error.message}`);
      } finally {
        hideProgress();
        storeBtn.disabled = false;
      }
    }

    // FIXED: Better data retrieval with proper cursor handling
    async function logFarmData() {
      const logBtn = document.getElementById('logBtn');
      logBtn.disabled = true;
      
      try {
        showStatus("Retrieving farm data...", 'info');
        consoleOutput.textContent = ''; // Clear previous output
        
        const db = await openDB();
        const tx = db.transaction(storeName, "readonly");
        const store = tx.objectStore(storeName);

        let count = 0;
        const maxEntries = 10;
        
        logToConsole("=== FARM DATA ENTRIES ===\n");

        // FIXED: Proper cursor iteration with error handling
        const request = store.openCursor();
        
        request.onsuccess = (event) => {
          const cursor = event.target.result;
          
          if (cursor && count < maxEntries) {
            const data = cursor.value;
            count++;
            
            logToConsole(`üìä Entry ${count} (ID: ${data.id || 'N/A'}):`);
            logToConsole(`   üå°Ô∏è  Sensor Readings: [${data.sensorReadings.join(', ')}]`);
            logToConsole(`   üì∏ Crop Photo: ${data.cropPhoto}`);
            logToConsole(`   üìù Farmer Note: ${data.farmerNote}`);
            
            // FIXED: Handle GPS coordinates properly
            if (data.gpsCoordinates) {
              if (typeof data.gpsCoordinates === 'object') {
                logToConsole(`   üìç GPS: Lat ${data.gpsCoordinates.latitude}, Lng ${data.gpsCoordinates.longitude}`);
              } else {
                logToConsole(`   üìç GPS: ${data.gpsCoordinates}`);
              }
            }
            
            // FIXED: Additional fields
            if (data.cropType) logToConsole(`   üåæ Crop Type: ${data.cropType}`);
            if (data.soilMoisture) logToConsole(`   üíß Soil Moisture: ${data.soilMoisture}%`);
            if (data.temperature) logToConsole(`   üå°Ô∏è  Temperature: ${data.temperature}¬∞C`);
            if (data.humidity) logToConsole(`   üí® Humidity: ${data.humidity}%`);
            
            logToConsole(`   ‚è∞ Timestamp: ${new Date(data.timestamp).toLocaleString()}`);
            logToConsole('   ' + '‚îÄ'.repeat(80) + '\n');
            
            cursor.continue();
          } else {
            // FIXED: Proper completion handling
            if (count === 0) {
              logToConsole("No entries found in database. Store some data first!");
              showStatus("No entries found. Store some data first!", 'info');
            } else {
              logToConsole(`\n‚úÖ Displayed ${count} entries from IndexedDB`);
              showStatus(`Successfully retrieved ${count} entries`, 'success');
            }
            
            db.close();
            logBtn.disabled = false;
          }
        };
        
        request.onerror = () => {
          console.error("Cursor error:", request.error);
          logToConsole(`‚ùå Error reading data: ${request.error}`);
          showStatus("Error reading data", 'error');
          logBtn.disabled = false;
          db.close();
        };
        
      } catch (error) {
        console.error("Error retrieving data:", error);
        showStatus(`‚ùå Error retrieving data: ${error.message}`, 'error');
        logToConsole(`‚ùå Error retrieving data: ${error.message}`);
        logBtn.disabled = false;
      }
    }

    // NEW: Clear database function
    async function clearDatabase() {
      if (!confirm("Are you sure you want to clear all data?")) return;
      
      try {
        const db = await openDB();
        const tx = db.transaction(storeName, "readwrite");
        const store = tx.objectStore(storeName);
        
        await new Promise((resolve, reject) => {
          const request = store.clear();
          request.onsuccess = resolve;
          request.onerror = reject;
        });
        
        db.close();
        showStatus("‚úÖ Database cleared successfully!", 'success');
        logToConsole("‚úÖ Database cleared successfully!");
        
      } catch (error) {
        console.error("Error clearing database:", error);
        showStatus(`‚ùå Error clearing database: ${error.message}`, 'error');
      }
    }

    // NEW: Count entries function
    async function countEntries() {
      try {
        const db = await openDB();
        const tx = db.transaction(storeName, "readonly");
        const store = tx.objectStore(storeName);
        
        const request = store.count();
        request.onsuccess = () => {
          const count = request.result;
          showStatus(`Database contains ${count} entries`, 'info');
          logToConsole(`üìä Total entries in database: ${count}`);
        };
        
        db.close();
        
      } catch (error) {
        console.error("Error counting entries:", error);
        showStatus(`‚ùå Error counting entries: ${error.message}`, 'error');
      }
    }

    // Initialize on page load
    window.addEventListener('load', async () => {
      try {
        await openDB();
        logToConsole("üå± AgricultureDB initialized successfully!");
        showStatus("Database initialized successfully!", 'success');
      } catch (error) {
        console.error("Failed to initialize database:", error);
        showStatus(`‚ùå Failed to initialize database: ${error.message}`, 'error');
      }
    });
  </script>
</body>
</html>
